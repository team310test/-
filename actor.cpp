#include "all.h"

void ActorBehavior::moveY(OBJ2D* obj) const
{
    // 最大速度チェックを行う
    obj->transform_->velocity_.y = clamp(obj->transform_->velocity_.y, -getParam()->SPEED_Y_MAX, getParam()->SPEED_Y_MAX);

    // 位置更新
    float oldY = obj->transform_->position_.y;           // 移動前の位置を保持
    obj->transform_->position_.y += obj->transform_->velocity_.y;
    float deltaY = obj->transform_->position_.y - oldY;  // 移動後の位置から移動前の位置を引く
}

void ActorBehavior::moveX(OBJ2D* obj) const
{
    // 最大速度チェック
    if (obj->transform_->velocity_.x > getParam()->SPEED_X_MAX) obj->transform_->velocity_.x = getParam()->SPEED_X_MAX;
    if (obj->transform_->velocity_.x < -getParam()->SPEED_X_MAX) obj->transform_->velocity_.x = -getParam()->SPEED_X_MAX;

    // X方向移動
    float oldX = obj->transform_->position_.x;
    obj->transform_->position_.x += obj->transform_->velocity_.x;
    float deltaX = obj->transform_->position_.x - oldX;
}

void ActorBehavior::move(OBJ2D* obj) const
{
    obj->renderer_->animeData_ = nullptr;
    switch (obj->state_)
    {
    case 0:
        //////// 初期設定 ////////
        // アニメの初期設定
        obj->renderer_->animeData_ = getParam()->ANIME_RIGHT;
        obj->transform_->scale_ = getParam()->SCALE;
        obj->collider_->size_ = {
            getParam()->SIZE.x * getParam()->SCALE.x, 
            getParam()->SIZE.y * getParam()->SCALE.y
        };
        obj->actorComponent_->hp_ = getParam()->HP;

        init(obj);

        obj->state_++;
        break;

    case 1:
        //////// 通常時 ////////

        damageProc(obj);
        shrink(obj);    // 画像縮小

        moveY(obj);
        moveX(obj);
        areaCheck(obj);
        attack(obj);
        break;
    }

    obj->collider_->calcHitBox(getParam()->HIT_BOX);
    obj->collider_->calcAttackBox(getParam()->ATTACK_BOX);

    // アニメーション更新
    obj->renderer_->animeData_ = getParam()->ANIME_LEFT;

    if (obj->renderer_->animeData_) 
        obj->renderer_->animeUpdate();
}

// 縮小中かの判定
//bool ShrinkJudge(OBJ2D* obj,VECTOR2 targetScale)
//{
//    if (obj->collider_->targetScale_.x == 0 ||
//        obj->collider_->targetScale_.y == 0)
//        return false;
//
//    if (obj->transform_->scale_.x > targetScale.x)
//        return true;
//    if (obj->transform_->scale_.x > targetScale.y)
//        return true;
//
//    return false;
//}

// 縮小関数
static const float divideValue = 0.5f;     // scaleを割る値(最終的なscaleの大きさに影響)
static const float shrinkValue = -0.0025f; // 縮小する値(縮小速度に影響)
void Behavior::shrink(OBJ2D* obj) const
{
    VECTOR2* currentScale = &obj->transform_->scale_;      // 現在のscale
    VECTOR2* targetScale = &obj->collider_->targetScale_;  // 最終的に目指すscale 
    bool* isShrink = &obj->collider_->isShrink_;           // 縮小しているか判定


    if ((GameLib::input::TRG(0) & GameLib::input::PAD_TRG1) &&  // Zを押したとき
        *isShrink == false)                                     // Shrinkしていなければ
    {
        *targetScale = (*currentScale) * divideValue;           // 現在のscaleの?分の?を最終目標に設定
        *isShrink = true;                                       // Shrink開始
    }


    if (*isShrink == false) return; // Shrinkしていなければreturn


    // Shrink中の場合
    if (currentScale->x > targetScale->x) // 最終目標より現在のscaleが大きければ
    {
        *currentScale += {                // 縮小
            shrinkValue * obj->transform_->scale_.x, 
            shrinkValue * obj->transform_->scale_.y
        };  
        if (currentScale->x < targetScale->x)  *currentScale = *targetScale; // 最終目標より小さくなったら値を修正
    }

    // 目標を達成した場合
    if (currentScale->x == targetScale->x)
    {
        *isShrink = false;           // Shrink終了
       
        //obj->actorComponent_->padTrg_ = GameLib::input::TRG(0);
        //obj->actorComponent_->padState_ = GameLib::input::STATE(0);
    }

}
